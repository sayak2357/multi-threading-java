ğŸ”´ LEVEL 5 â€” ADVANCED CONCURRENCY UTILITIES

Use java.util.concurrent tools for robust real-world code.


ğŸ§© Q22 â€“ AtomicInteger Counter

Goal: Use atomic variables.
Requirements:

Implement thread-safe counter using AtomicInteger.

Compare with synchronized version (speed & simplicity).

ğŸ§© Q23 â€“ CountDownLatch

Goal: Wait for multiple threads to finish setup.
Requirements:

3 worker threads count down latch.

Main waits with await(), prints â€œAll ready!â€.

ğŸ§© Q24 â€“ CyclicBarrier

Goal: Start threads together.
Requirements:

Create 3 player threads.

All wait at barrier before printing â€œStarted!â€.

ğŸ§© Q25 â€“ Semaphore

Goal: Limit concurrent access.
Requirements:

5 cars, 3 parking slots.

Only 3 acquire permits at a time.

ğŸ§© Q26 â€“ Phaser

Goal: Multi-phase coordination.
Requirements:

3 tasks, 3 phases (load â†’ process â†’ save).

All must finish one phase before next begins.

ğŸ§© Q27 â€“ ConcurrentHashMap

Goal: Safe concurrent updates.
Requirements:

Multiple writer threads add to shared map.

Print map after all complete.

Compare with normal HashMap failure.

ğŸ§© Q28 â€“ CompletableFuture Chain

Goal: Asynchronous chaining.
Requirements:

Simulate data fetch (sleep).

Transform result using thenApply().

Handle exception with exceptionally().

ğŸ§© Q29 â€“ Parallel Stream

Goal: Use Java 8 parallelism.
Requirements:

List of integers 1â€“100.

Filter primes using .parallelStream().

Compare time with sequential stream.